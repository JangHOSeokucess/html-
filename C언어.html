<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            background-image: url(tototo.avif);
            background-repeat: none;
            width: auto;
            height: auto;
            
        }
        h1{
            color: black;
        }
        .j{}
    </style>
</head>
<body>
    <h1>C언어</h1>
    <nav>
    <div>
        <h3 class="j">도움이 될만한 자료들</h3>
        <ul>
            <li><a href="https://www.youtube.com/@nadocoding" style="color: black;"><h4>나도 코딩 강의 영상</h4></a></li>
            <li><a href="https://www.youtube.com/results?search_query=%EC%A1%B0%EC%BD%94%EB%94%A9" style="color: black;">조코딩<h4></h4></a></li>
            <li><a href="https://www.youtube.com/watch?v=jMrb9SWMa84" style="color: black;"><h4>reddit 사용법</h4></a></li>
        </ul>
        <ul>
            <li><a href="#1" style="color: white;">프로그램의 기본 구성과 기본 자료형</a><br></li> 
            <li><a href="#2" style="color: white;">함수와 변수</a><br></li>
            <li><a href="#3" style="color: white;">배열과 문자열</a><br></li> 
            <li> <a href="#4" style="color: white;">포인터와 배열</a><br></li>
            <li> <a href="#5" style="color: white;">다차원 배열과 포인터</a><br></li>
            <li> <a href="#6" style="color: white;">함수 포인터와 void 포인터</a><br></li>
            <li> <a href="#7" style="color: white;">표준 입출력, 문자와 문자열 처리 함수</a><br></li>
            <li> <a href="#8" style="color: white;">구조체와 typedef</a><br></li>
            <li> <a href="#9" style="color: white;">파일 입출력</a><br></li>
            <li> <a href="#10" style="color: white;">메모리 동적 할당, 선행처리기, 매크로 , 해더파일</a><br></li>
        </ul>
    </div>
    </nav>
    <div>
        <h3>프로그래밍 기본 구성과 기본 자료형</h3>
        <p>
            
프로그래의 기본 구성 <a name="1">프로그램의 기본 구성과 기본 자료형</a>

int main(void)<br>
{<br>
  return 0; // 정상 종료 코드 0<br>
}<br>
<br>
<br>
<br>
변수와 연산자<br>
<br>
'값을 저장할 수 있는 메모리 공간에 붙은 이름, 혹은 메모리 공간 자체를 가리켜 변수라 한다.'<br>
<br>
<br>
int num;<br>
    int : 정수의 저장이 가능한 메모리 공간을 할당<br>
    num : 그리고 메모리 공간의 이름을 num이라 한다.<br>
    <br>
"변수를 선언만 하고 초기화하지 않으면 쓰레기 값지 저장된다."<br>
<br>
<br>
#include <stdio.h><br>
int main(void)<br>
{<br>
int num1;  <br>
num1=0;<br>
int num2; // 컴파일 에러가 발생할 수 있다. 가능하면 선언은 가장 앞쪽에 둔다.<br>
num2 =0; <br>
}<br>
<br>
<br>
<br>
기본 자료형<br>
<br>
int, float 등 자료형을 나눈 것은,<br>
정수냐, 실수냐에 따라 값이 메모리 공간에 저장 및 참조되는 방식이 다르기 때문.<br>
<br>
<br>
<, >, ==, !=, <=, >= 등의 관계 연산자는,<br>
조건을 만족하면 1, 만족하지 않으면 0을 리턴한다.<br>
<br>
<br>
C 언어는 0이 아닌 모든 값을 true로 간주한다.<br>
<br>
<br>
scanf("%d", &num); // 키보드로 입려된 정수를 변수 num에 저장한다.<br>
<br>
<br>
C언어의 표준 키워드.<br>
auto _Bool break case char _Complex const continue default do double else<br>
enum extern float for goto if _Imaginary return restrict short signed sizeof static<br>
struct switch typedef union unsigned void volatile while<br>
<br>
<br>
'비트': 컴퓨터가 표현하는 데이터의 최소 단위. 2진수 값 하나를 저장<br>
'바이트': 8비트<br>
<br>
1 : 1비트<br>
10000000 : 1바이트<br>
<br>
10000000 = 128<br>
11111111 = 255<br>
<br>
n개의 bit로 표현하는 데이터 수 = 2의 n제곱<br>
<br>
<br>
int num1 = 10; // 10진수<br>
int num2 = 0xA; // 0x로 시작하면 16진수<br>
int num3 = 012; // 0으로 시작하면 8진수<br>
<br>
(내부적으로는 모두 2진수 형태로 값을 저장)<br>
<br>
<br>
C언어는 보통 하나의 정수를 4바이트로 표현.<br>
정수의 가장 왼쪽에 존재하는 비트는 '부호비트'<br>
이 비트를 MSB라 하며 Most Significan Bit의 약자로 가장 중요한 비트를 뜻한다.<br>
양수라면 0, 음수라면 1.<br>
<br>
음의 정수를 표현할 때에는 2의 보수를 취한다.<br>
( ~num + 1)<br>
<br>
<br>
<br>
실수 표현을 위해 정의된 수식<br>
                e-127<br>
+-(1.m)x2<br>
<br>
표현할 수 있는 범위가 크지만 오차가 있다. --> 부동 소수점 오차<br>
<br>
<br>
e표기법<br>
0.0001<br>
= 1.0 x 10^-4 (10의 -4승)<br>
= 1.0e-4<br>
<br>
1240<br>
= 1.24 x 10^3<br>
= 1.24e+3<br>
<br>
<br>
비트 연산자<br>
& : 두 개 비트가 모두 1일 때 1<br>
| : 둘 중 하나가 1이라면 1<br>
^ : 서로 다른 경우 1<br>
~ : 반전<br>
<< : 왼쪽 시프트, 정수의 값은 두 배가 된다.<br>
>> : 오른쪽 시프트, 정수의 값은 2로 나누어진다.<br>
<br>
<br>
<br>
자료형(data type)은 데이터를 표현하는 기준. 변수도 상수도 자료형에 근거한다.<br>
<br>
자료형 별 크기는 컴파일러마다 차이를 보인다.<br>
<br>
자료형은 왜 다른가?<br>
- 데이터의 표현 방식이 다르므로 (예: 정수와 실수)<br>
- 메모리 공간의 적절한 사용을 위해<br>
<br>
sizeof(num) sizeof(int) 연산자를 사용해 자료형의 크기 확인 가능<br>
<br>
"int 형 연산이 CPU가 성능을 내기에 가장 좋은 연산이다.<br>
따라서 int보다 작은 크기의 데이터는 int형 데이터로 형변환 되어 계산된다."<br>
<br>
<br>
<br>
실수를 표현하기 위한 자료형의 선택에 있어서 가장 중요한 요소는 "정밀도"이다.<br>
정밀도 = '오차가 발생하지 않는 소수점 이하의 자릿수'<br>
<br>
실수 자료형 | 소수점 이하 정밀도 | 바이트 수<br>
float | 6자리 | 4<br>
double | 15자리 | 8<br>
long double | 18 | 12<br>
<br>
"가장 보편적인 실수 자료형은?" ---> double<br>
<br>
double형 데이터는, 입력받을 때는 %lf, 출력할 때는 %f를 사용한다.<br>
<br>
<br>
<br>
unsigned int = 0과 양의 정수만 표현<br>
- 정수 자료형 앞에만 붙일 수 있다.<br>
- MSB도 데이터 크기를 표현하는데 사용<br>
- 표현할 수 있는 범위도 2배<br>
<br>
<br>
<br>
문자의 표현을 위한 약속! 아스키 코드!<br>
"문자 A는 숫자 65, 문자 B는 숫자 66"<br>
C언어는 '미국 표준 협회(ANSI: American National Stadards Institute')에 의해 제정된<br>
'아스키(ASCII: American Standard Code for Information Interchange) 코드'를 표준으로 선택해 문자를 표현.<br>
<br>
char c = 'A';<br>
printf("%c %d", c, c); //--> A 65<br>
<br>
아스키코드는 0이상 127이하.<br>
char는 1바이트이니까.<br>
(실제로 char형은 정수형이다. 정수가 저장되므로)<br>
<br>
<br>
상수<br>
int n = 3 + 5 // 3과 5는 각각 상수<br>
할당된 메모리 공간에 이름이 없다.<br>
'리터럴 상수' 또는 '리터럴'<br>
<br>
리터럴 상수의 자료형.<br>
"어떠한 자료형으로 저장을 해야 하나?"<br>
메모리상에 저장되는 모든 데이터는 자료형이 결정되어야 한다.<br>
<br>
기본!<br>
--> int 형으로 표현 가능한 정수형 상수는 int형으로 저장.<br>
--> double형으로 표현 가능한 실수형 상수는 double 형으로 저장.<br>
<br>
float n = 5.789f; // float형은 f를 붙여야 한다.<br>
<br>
<br>
자료형에 대한 접미사<br>
unsigned int n = 1025U;<br>
long n  =2476L;<br>
unsigned long n = 345UL;<br>
long long n = 577LL;<br>
unsigned long long = 5556ULL;<br>
<br>
float f = 3.15F;<br>
long double f = 5.789L;<br>
<br>
<br>
이름을 지니는 상수 = 심볼릭 상수<br>
const int MAX = 100; // 변경 불가하다.<br>
<br>
<br>
<br>
자료형의 변환.<br>
데이터 크기가 큰 자료형을 작은 자료형으로 형 변환하는 경우,<br>
데이터 손실 뿐 아니라 부호가 바뀌는 경우도 있으니 주의한다.<br>
<br>
double num1 = 5.15 + 19;<br>
정수와 실수는 표현방식이 다르므로 사실 상 덧셈이 불가하다.<br>
CPU는 같은 자료형의 두 피연산자를 대상으로만 연산이 가능하도록 설계되어 있기 때문이다.<br>
피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행된다.<br>
int -> long -> long long -> float -> double -> long double<br>
<br>
<br>
기준은 '데이터 손실의 최소화!'<br>
형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의<br>
<br>
int a = 3, b = 4;<br>
double r1 = a / b;<br>
double r2 = (double)a / b;<br>
<br>
printf("%f\n", r1);<br>
printf("%f\n", r2);<br>
        </p><br>
        <h3 >함수와 변수</h3><a name="2"></a><br>
        <p><br>
            printf<br>
            <br>
            \ = escape squence<br>
            <br>
            서식문자<br>
            %d  char, short, int  부호있는 10진수 정수<br>
            %ld  long  부호있는 10진수 정수<br>
            %lld  long long<br>
            %u  unsigned int<br>
            %o  unsigned int  8진수 정수 (%#o 로 출력하면 07과 같은 식으로)<br>
            %x, %X  unsigned int 16진수 정수 (%#x 로 출력하면 0x7과 같은 식으로)<br>
            %f  float, double<br>
            %lf  long double<br>
            %e, %E  float, double  10진수 방식의 부동소수점 실수<br>
            %g, %G  float, double  값에 따라 %f, %e 중 선택<br>
            %c  char, short, int  값에 대응하는 문자<br>
            %s  char*  문자열<br>
            %p  void*  포인터의 주소값<br>
            <br>
            출력 시 필드 폭 지정하여 정돈하기 <br>
            <br>
            %8d  필드 폭을 8칸 확보하고, 오른쪽 정렬한다.<br>
            %-8d  필드 폭을 8칸 확보하고, 왼쪽 정렬한다.<br>
            <br>
            <br>
            scanf<br>
            <br>
            scanf("어떻게 받아들일래?", "어디에 저장할래?")<br>
            <br>
            "float, double, long double 의 데이터 출력에 사용되는 서식문자는 각각 %f, %f, %Lf 이다."<br>
                                                                    입력   <br>                                     %f, %lf, %Lf
                                                                    <br>
                                                                    <br>
                                                                    <br>
            while<br>
            <br>
            while(CONDITION)<br>
            {<br>
              // do<br>
            }<br>
            <br>
            do {<br>
                <br>
            } while (…)<br>
            <br>
            <br>
            <br>
            for<br>
            <br>
            for (; ; ; ) {}<br>
            // 주의! for의 초기식 내에서 변수를 정의하지 않는다.<br>
            <br>
            if (CONDITION)<br>
            { <br>
                <br>
            } <br>
            else <br>
            {<br>
                <br>
            }<br>
            <br>
            <br>
            <br>
            switch<br>
            <br>
            switch (CONDITION)<br>
            {<br>
            case 1:<br>
            …<br>
            break;<br>
            default:<br>
            }<br>
            <br>
            <br>
            <br>
            goto<br>
            거의 사용하지 않는다. <br>
            <br>
            int main(void)<br>
            {<br>
                <br>
            goto ONE;<br>
            <br>
            ONE: <br>
                 // do soemthing<br>
                goto END;<br>
                <br>
            END:<br>
                return 0;<br>
                <br>
            }<br>
            <br>
            <br>
            <br>
            함수 정의<br>
            int add(int num1, int num2) { … }<br>
            <br>
            void doNothing(void) // 리턴값과 파라미터를 받지 않는 경우 void를 명시한다.<br>
            <br>
            <br>
            !! 함수는 호출되기 전에 미리 정의되어야 한다.<br>
            단, 선언과 정의를 분리해 미리 선언해둔다면 문제 없다.<br>
            <br>
            int add(int, int); // 매개변수 이름을 생략하고 선언<br>
            <br><br>
            <br>
            
            변수<br>
            <br>
            - 메모리상에 존재하는 시간.<br>
            - 변수에 접근할 수 있는 범위<br>
            <br>
            <br>
            '지역 변수' = "중괄호" 내에 선언되는 변수. 지역 변수의 스콥은 중괄호다.<br>
            지역변수는 '스택(stack)'이라는 메모리 영역에 할당된다.<br>
            지역변수는 해당 선언문이 실행될 때 메모리 공간에 할당되었다가,<br>
            선언문이 존재하는 함수가 반환을 하면(종료를 하면) 메모리 공간에서 소멸된다.<br>
            <br>
            <br>
            '전역 변수' = 프로그램이 실행되면 메모리 공간에 할당되었다가, 종료될 때까지 메모리 공간에 남아있는 변수<br>
            별도의 값을 초기화하지 않으면 0으로 할당된다.<br>
            <br>
            <br>
            static 변수 = 지역변수에 static 선언이 붙게 되면, 이는 전역변수의 성격을 지니는 변수가 된다.<br>
            - 선언된 함수 내에서만 접근이 가능하다<br>
            - 딱 1회 초기화되고 프로그램 종료시까지 메모리 공간에 존재한다<br>
            (전역 변수와 같은 성격을 갖지만, 접근 범위를 해당 함수 내로 제한하기 위해서)<br>
            <br>
            int i = 0;<br>
            for (i = 0; i < 5; i++)<br>
            {<br>
            static int num = 0;<br>
            printf("%d", num++);<br>
            }<br>
            <br>
            <br>
            register 변수 = CPU 내에 존재하는 '레지스터'라는 메모리 공간에 저장할 확률이 높이진다.<br>
            빈번히 사용하는 변수를 가장 접근이 빠른 레지스터에 저장하도록 한다.<br>
            하지만 최종 결정은 컴파일러가 내린다.<br>
            또한 지역 변수에만 선언 가능하다.<br>
            register int num = 3;<br>
            <br>
            <br>
            <br>
            재귀함수<br>
            실제로 함수를 구성하는 명령문은 CPU로 이동이 되어서(복사되어) 실행된다.<br>
            그래서 재귀 호출이 가능한 것!    <br>
        </p><br>
        <h3>배열과 문자열</h3> <a name="3"></a><br>
        <p><br>
            배열 선언<br>
            <br>
            int arr[3];<br>
            int len = 3;<br>
            int arr2[len];<br>
            int arr3[3] = {1, 2, 3};<br>
            int arr4[] = {1, 2, 3}; // 컴파일러에 의해 자동으로 3 삽입<br>
            int arr5[5] = {1, 2, 3}; // 나머지 부분은 0으로 채워짐<br>
            <br>
            <br>
            !! 배열의 크기를 벗어난 인덱스에 접근해도 컴파일 에러가 발생하지 않는다.<br>
            컴파일러는 배열 접근에 있어서는 유효성 검사를 진행하지 않기 때문이다.<br>
            이 경우, 할당하지 않은 메모리 공간을 침범하게 되므로 반드시 주의해야 한다.<br>
            <br>
            int arr[3];<br>
            arr[3] = 10; // 컴파일 에러를 발생하지 않는다.<br>
            <br>
            <br>
            배열의 이름을 대상으로 하는 sizeof 연산의 결과는 '바이트 단위의 배열의 크기'가 반환된다.<br> 
            <br>
            <br>
            <br>
            배열과 문자열<br>
            <br>
            C 언어는 큰 따옴표를 이용해 문자열을 표현한다.<br>
            <br>
            char str[] = "Good";<br>
            <br>
            메모리 공간에는 char형 배열이 할당되고, 이 배열에는 아래 형태로 저장된다. <br>
            [ G ] [ o ] [ o ] [ d ] [ \0 ]<br>
            총 5개의 공간이 생성되고 마지막에는 특수문자가 삽입된다.<br>
            <br>
            \0은 특수문자로 문자열 끝에 자동으로 삽입되면 'null'문자라 한다.<br>
            널 문자의 아스키 코드값은 0이고, 이를 문자 형태로 출력할 경우 아무런 출력이 발생하지 않는다.<br>
            <br>
            <br>
            scanf("%s", str); // 문자열을 입력받는 경우, &str 이라 하지 않는다.<br>
            또한, scanf로 입력받는 문자열의 끝에도 널 문자가 삽입되어 있다.<br>
            <br>
            !!! "C 언어에서 표현하는 모든 문자열의 끝에는 널 문자가 자동으로 삽입된다."<br>
            문자열에 있어서 널 문자의 존재는 매우 중요하다.<br>
            널 문자가 존재하면 문자열이고, 그렇지 않으면 문자열이 아니다.<br>
            <br>
            char arr1[] = {'H', 'i'} ; //--> 단순히 문자가 저장된 배열이다.<br>
            char arr2[] = {'H', 'i', '\0'}; //--> 문자열이다.<br>
            <br>
            널 문자는, 문자열의 끝은 표시하기 위한 문자이다.<br>
            널 문자의 아스키 코드는 0 이므로, 아래 두 문장은 동일하다.<br>
            str[8] = '\0';<br>
            str[8] = 0<br>
            </p><br>
            <h3>포인터와 배열</h3> <a name="4"></a><br>
            <br>
            <br>
<h3>>포인터 변수</3><br>
    <br>
<p>p1"포인터 변수란 메모리의 주소 값을 저장하기 위한 변수이다."<br>
    <br>
            & 연산자: 피연산자의 주소값을 반환하는 연산자<br>
            <br>
            포인터 변수의 크기는 하드웨어와 운영체제에 따라 달라진다.<br>
            32비트 시스템에서는 주소값을 32비트로 표현하기 때문에 포인터 변수의 크기는 4 바이트,<br>
            64비트 시스템에서는 64비트로 표현하기 때문에 8바이트 크기를 갖는다.<br>
            <br>
            int * : int 형 포인터<br>
            double * : double 형 포인터<br>
            <br>
            <br>
            int num1 = 5;<br>
            double *pnum1 = &num; // 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있다.<br>
                                                    // (컴파일 에러는 발생하지 않는다)<br>
                                                    <br>
            int *ptr1 = 0; 또는<br>
            int *ptr2 = NULL;<br>
            <br>
            0과 NULL의 의미는 동일하며, 모두 '널 포인터'를 의미한다.<br>
            '널 포인터'는 "아무 것도 가리키지 않는다!" 라는 뜻!<br>
            <br>
            <br>
            <br>
            포인터와 배열<br>
            <br>
            배열의 이름은 포인터이다. 단, 그 값을 바꿀 수 없는 '상수 형태의 포인터'이다.<br>
            그래서 배열의 이름을 '포인터 상수'라고도 한다.<br>
            <br>
            int형 포인터를 대상으로 n 증가 = n x sizeof(int) 크기만큼 증가<br>
            double형 포인터를 대상으로 n 증가 = n x sizeof(double) 크기만큼 증가<br>
            ==> TYPE 형 포인터를 대상으로 n의 크기만큼 값을 증가/감소 시, n x sizeof(TYPE)의 크기만큼 주소 값이 증가/감소한다.<br>
            <br>
            포인터의 증감 연산으로 배열처럼 접근할 수 있다.<br>
            즉, arr[i] == *(arr + i)<br>
            <br>
            <br>
            <br>
            문자열 배열과 포인터<br>
            <br>
            char str1[] = "My String"; // 변수 형태의 문자열<br>
            char *str2 = "Your String"; // 상수 형태의 문자열<br>
            <br>
            str1과 str2 모두 문자열의 시작 주소 값을 담고 있다.<br>
            단, str1은 항상 배열을 가리키는 상태여야 하지만 str2는 다른 위치를 가리킬 수 있다.<br>
            <br>
            상수 형태의 문자열은 변경할 수 없다.<br>
            예) str2[0] = 'X'; // 안된다.<br>
            <br>
            상수 형태의 문자열은 먼저 문자열이 메모리 공간에 저장된 후 그 주소값을 반환한다.<br>
            printf("abc"); 에서 넘기는 것도 동일하다.<br>
            예를 들어, WhoAreYou("hong")과 같은 함수를 호출했다면,<br>
            void WhoAreYou(char *str) 과 같이 되어 있어야 한다.<br>
            <br>
            <br>
            <br>
            포인터 배열<br>
            <br>
            포인터 배열: 포인터 변수로 이뤄진 배열<br>
            주소값의 저장이 가능한 배열<br>
            <br>
            int* arr[3] = {p1, p2, p3};<br>
            (즉, 배열의 인자로 포인터가 들어있다)<br>
            <br>
            <br>
            문자열 포인터 배열<br>
            char * strArr[3] = {"Simple", "String", "Array"}<br>
            <br>
            (즉, 배열의 인자로 문자열 포인터가 들어있다.<br>
            문자열은 자동으로 생성되어 첫 번째 문자의 주소를 리턴한다)<br>
            <br>
            <br>
            <br>
            포인터와 함수<br>
            <br>
            int main(void)<br>
            {<br>
            int arr[3] = {1, 2, 3};<br>
            ShowElement(arr);<br>
            }<br>
            void ShowElement(int *arr) // 동일하다. <br>
            void ShowElement(int arr[]) // 참조로 넘길 수 있다.<br>
            <br>
            <br>
            <br>
            Call-by-value vs Call-by-reference<br>
            <br>
            Call-by-value : 단순히 값을 전달<br>
            Call-by-reference : 메모리 접근에 사용되는 주소값을 전달<br>
            <br>
            int num;<br>
            char str[30];<br>
            scanf("%d", &num); // 입력을 받아 num에 할당<br>
            scanf("%s", str); // str 자체가 배열의 주소<br>
            <br>
            <br>
            <br>
            포인터 대상의 const 선언<br>
            <br>
            const int *ptr = &num; // 포인터 변수 ptr을 이용해서 ptr이 가리키는 값을 변경하는 것을 허용하지 않는다. (*ptr=40 안됨)<br>
            int * const ptr = &num; // 한 번 가리키기 시작한 변수를 끝까지 가리켜야 한다. (ptr=&num2 안됨)<br>
            </p><br>
            <h3>끝</h3><br>
    </d> 
</body>
</html>